package dictionarygen

import (
	"bytes"
	"errors"
	"go/format"
	"strconv"

	"layeh.com/radius/dictionary"
)

type externalAttribute struct {
	Attribute  string
	ImportPath string

	Values []*dictionary.Value
}

type Generator struct {
	// Output package name.
	Package string
	// Attributes that will be ignored during generation.
	IgnoredAttributes []string
	// Map of external attributes to import path where the attribute is
	// defined.
	ExternalAttributes map[string]string
}

func (g *Generator) Generate(dict *dictionary.Dictionary) ([]byte, error) {

	attrs := make([]*dictionary.Attribute, 0, len(dict.Attributes))

	ignoredAttributes := make(map[string]struct{}, len(g.IgnoredAttributes))
	for _, attrName := range g.IgnoredAttributes {
		ignoredAttributes[attrName] = struct{}{}
	}

	for _, attr := range dict.Attributes {
		if _, ignored := ignoredAttributes[attr.Name]; ignored {
			continue
		}

		invalid := false
		if attr.Size != nil {
			invalid = true
		}
		if attr.FlagHasTag != nil {
			invalid = true
		}
		if attr.FlagEncrypt != nil && *attr.FlagEncrypt != 1 {
			invalid = true
		}
		switch attr.Type {
		case dictionary.AttributeString:
		case dictionary.AttributeOctets:
		case dictionary.AttributeIPAddr:
		case dictionary.AttributeInteger:
		case dictionary.AttributeVSA:
		default:
			invalid = true
		}

		if invalid {
			return nil, errors.New("dictionarygen: cannot generate code for attribute " + attr.Name)
		}

		attrs = append(attrs, attr)
	}

	dictionary.SortAttributes(attrs)

	externalAttributes := make([]*externalAttribute, 0, len(g.ExternalAttributes))
	for attribute, importPath := range g.ExternalAttributes {
		externalAttributes = append(externalAttributes, &externalAttribute{
			Attribute:  attribute,
			ImportPath: importPath,
		})
	}
	sortExternalAttributes(externalAttributes)

	values := make([]*dictionary.Value, 0, len(dict.Values))
	for _, value := range dict.Values {
		if _, ignored := ignoredAttributes[value.Attribute]; ignored {
			continue
		}

		var isLocalAttr bool
		for _, attr := range attrs {
			if value.Attribute == attr.Name {
				isLocalAttr = true
				break
			}
		}
		if isLocalAttr {
			values = append(values, value)
			continue
		}

		var ea *externalAttribute
		for _, exAttr := range externalAttributes {
			if value.Attribute == exAttr.Attribute {
				ea = exAttr
				break
			}
		}
		if ea == nil {
			return nil, errors.New("dictionarygen: unknown attribute " + value.Attribute)
		}

		ea.Values = append(ea.Values, value)
	}
	dictionary.SortValues(values)

	var w bytes.Buffer

	p(&w, `// Generated by radius-dict-gen. DO NOT EDIT.`)
	p(&w)
	p(&w, `package `, g.Package)

	// Imports
	p(&w)
	p(&w, `import (`)
	p(&w, `	"net"`)
	p(&w, `	"strconv"`)
	p(&w)
	p(&w, `	"layeh.com/radius"`)
	if len(externalAttributes) > 0 {
		printedNewLine := false
		for _, exAttr := range externalAttributes {
			if len(exAttr.Values) > 0 {
				if !printedNewLine {
					p(&w)
					printedNewLine = true
				}
				p(&w, `	. `, strconv.Quote(exAttr.ImportPath))
			}
		}
	}
	p(&w, `)`)

	// Prevent unused import errors
	p(&w)
	p(&w, `var _ = radius.Type(0)`)
	p(&w, `var _ = strconv.Itoa`)
	p(&w, `var _ = net.ParseIP`)

	// Attribute types
	if len(attrs) > 0 {
		p(&w)
		p(&w, `const (`)
		for _, attr := range attrs {
			p(&w, `	`, identifier(attr.Name), `_Type radius.Type = `, attr.OID)
		}
		p(&w, `)`)
	}

	for _, exAttr := range externalAttributes {
		p(&w)
		p(&w, `func init() {`)
		for _, value := range exAttr.Values {
			attrIdent := identifier(value.Attribute)
			valueIdent := identifier(value.Name)
			p(&w, `	`, attrIdent, `_Strings[`, attrIdent, `_Value_`, valueIdent, `] = `, strconv.Quote(value.Name))
		}
		p(&w, `}`)

		p(&w)
		p(&w, `const (`)
		for _, value := range exAttr.Values {
			attrIdent := identifier(value.Attribute)
			valueIdent := identifier(value.Name)
			p(&w, `	`, attrIdent, `_Value_`, valueIdent, ` `, attrIdent, ` = `, strconv.Itoa(value.Number))
		}
		p(&w, `)`)
	}

	for _, attr := range attrs {
		switch attr.Type {
		case dictionary.AttributeString, dictionary.AttributeOctets:
			g.genAttributeStringOctets(&w, attr)
		case dictionary.AttributeIPAddr:
			g.genAttributeIPAddr(&w, attr)
		case dictionary.AttributeInteger:
			g.genAttributeInteger(&w, attr, values)
		case dictionary.AttributeVSA:
			// skip
		}
	}

	for _, vendor := range vendors {
		for _, attr := range vendor.Attributes {
			switch attr.Type {
			//case dictionary.AttributeString, dictionary.AttributeOctets:
			//	g.genAttributeStringOctets(&w, attr)
			case dictionary.AttributeIPAddr:
				g.genVendorAttributeIPAddr(&w, vendor, attr)
			//case dictionary.AttributeInteger:
			//	g.genAttributeInteger(&w, attr, values)
			case dictionary.AttributeVSA:
				// skip
			}
		}
	}

	formatted, err := format.Source(w.Bytes())
	if err != nil {
		return nil, err
	}
	return formatted, nil
}
